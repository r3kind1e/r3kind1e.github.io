---
layout: post
title: "Buffer Overflow Attacks"
date: "2022-07-11"
author: "r3kind1e"
header-img: "img/post-bg-Penetration Testing Student.png"
catalog:    true
tags: 
    - Penetration Testing Student
    - System Attacks
---

# Buffer Overflow Attacks - Study Guide
这如何支持我的渗透测试生涯？
* 远程代码执行
* 权限提升攻击
* 了解内存损坏攻击的基础知识

许多不同的攻击广泛利用**缓冲区溢出漏洞**。 它们通过控制一个软件或操作系统例程的执行流程来工作。
控制程序的执行意味着能够强制它的行为与应用程序作者设计的不同。

缓冲区溢出攻击可能导致：
* 应用程序或操作系统崩溃，从而导致拒绝服务
* 权限提升
* 远程代码执行
* 安全功能绕过

在下面的幻灯片中，您将看到缓冲区溢出漏洞是如何出现的，以及熟练的攻击者如何利用它。

## Buffers
**缓冲区**是计算机随机存取存储器 (RAM) 中保留用于临时数据存储的区域。 数据如：
* 用户输入
* 视频文件的一部分
* 客户端应用程序接收到的服务器横幅
* 等等

缓冲区的**大小是有限的**； 这意味着它们只能包含一定数量的数据。
如果客户端-服务器应用程序设计为只接受 8 个字符长的用户名，则用户名缓冲区将是 8 个字节长。

![8-characters-long-username.png](/img/in-post/ine/8-characters-long-username.png)

如果应用程序的开发人员不强制执行缓冲区的限制，攻击者可能会找到一种方法来写入超出这些限制的数据，从而实际上在计算机 RAM 中写入任意代码； 可以利用它来控制程序执行流程！

### Buffer Overflow Example
开发人员创建了一个文本编辑器。 根据设计，单行的最大长度为 256 个字符，因此编辑器不接受创建长度超过 256 个字符的行的用户输入。
一名渗透测试人员发现，当打开使用另一个编辑器创建的文件时，应用程序不会强制执行此限制。 此外，当编辑器打开一个文件时，它会将第一行插入到行缓冲区中。

因此，如果渗透测试人员创建了一个只有一行的文件，比如说 512 个随机字符，然后用编辑器打开它，应用程序就会崩溃！ 这意味着文件中的数据在某种程度上覆盖了加载到 RAM 中的一些编辑器代码。
然后渗透测试人员编写一个脚本，首先生成行很长的文件，然后用应用程序打开它们。

经过反复试验，渗透测试人员能够生成文件，当使用编辑器打开这些文件时，会用有效代码覆盖程序执行流程，从而使渗透测试人员能够控制应用程序。
这个例子应该让你对缓冲区溢出攻击的工作原理有了一个基本的了解。 让我们更深入地研究它们！

## The Stack
缓冲区存储在计算机内存中称为堆栈的特殊数据结构中。
**堆栈**是一种用于存储数据的数据结构。

您可以将堆栈想象成一堆盘子，一次只能添加或移除一个盘子； 这意味着您只能在桩顶添加一个盘子或从桩顶移除一个盘子。

这种方法称为**后进先出 (LIFO)**，使用两种方法：
* **Push**，将一个元素添加到堆栈中
* **Pop** 移除最后插入的元素

### Push Operation
Push 在栈顶添加元素。
如果我们将A然后B添加到堆栈中，它将按照下图变化：

![push-operation.png](/img/in-post/ine/push-operation.png)

### Pop Operation
Pop 从栈顶移除一个元素。 从堆栈中删除的元素可以由弹出它的软件例程使用。

![pop-operation.png](/img/in-post/ine/pop-operation.png)

### Allocating Space on the Stack（在堆栈上分配空间）
在现代操作系统中，堆栈以更灵活的方式使用。 即使仍然使用 push 和 pop，应用程序也可以随机访问堆栈上的某个位置来读取和写入数据。
为了节省一些堆栈空间供以后使用，应用程序可以简单地在堆栈上保留一些内存分配，然后访问它们。

如果应用程序需要存储三个整数的数组，它可以在堆栈上分配三个位置。
C 语言中的应用程序代码可以是：`int A[3] = {2, 3, 4};`

![inta234.png](/img/in-post/ine/inta234.png)

分配两个数组：

```
int A[3] = {2, 3, 4};
int B[2] = {7, 9};
```

![a234b79.png](/img/in-post/ine/a234b79.png)

### Overflows in the Stack（堆栈中的溢出）
前面的示例显示了堆栈是如何自下而上增长的，而变量是自上而下编写的。 所以参考前面的例子，如果攻击者在 B 中写入两个以上的整数会发生什么？
他们将能够覆盖 A ！！！

如果攻击者找到一种方法将一个**四元素数组**复制到 B 上，他们将覆盖 A 的一部分。
这张图片显示了通过在 B 上复制以下数组执行的溢出：`int overflow[4] = {1, 1, 0, 0};`

![boverflowa.png](/img/in-post/ine/boverflowa.png)

攻击者利用缓冲区溢出漏洞后，应用程序会看到A内容为{0,0,4}！

![a-content-as004.png](/img/in-post/ine/a-content-as004.png)

## The Stack in an Application（应用程序中的堆栈）
应用程序和操作系统使用的堆栈不仅包含数据，还包含**有关执行流程的信息**。
如果我们分析一个函数调用，我们会看到堆栈包含函数参数、它的局部变量以及函数返回后程序必须继续执行的内存地址。

因此，覆盖函数返回地址意味着获得对应用程序的控制权。 此外，如果攻击者设法在 RAM 中编写了一些有效代码，他们可以强制受害者函数运行他们的代码。
仅覆盖某些内存位置的原始溢出将使应用程序崩溃，而精心设计的攻击能够在受害机器上执行代码。

## How Buffer Overflow Attacks Work（缓冲区溢出攻击的工作原理）
关于堆栈如何在操作系统中工作的深入分析超出了本课程的范围。

看这张图你应该明白，如果攻击者设法溢出局部变量 1，他们就能够覆盖基指针，然后返回地址！

![how-buffer-overflow-attacks-work.png](/img/in-post/ine/how-buffer-overflow-attacks-work.png)

如果他们用正确的值覆盖返回地址，他们就能够控制程序的执行流程！
可以通过编写自定义工具和应用程序或使用 Metasploit 等黑客工具来利用此技术。

接下来是网络攻击，您将在其中看到使用 Metasploit 进行的真实缓冲区溢出利用！

能够编写缓冲区溢出漏洞需要深入了解汇编编程、应用程序和操作系统的工作原理以及一些特殊的编程技能。